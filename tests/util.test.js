import util from 'util'
import { checkUrl, parseUrl, isBinary, isText } from '../src/util'

describe('util tool test', () => {
  beforeAll(async () => {
  })

  afterAll(async () => {
  })

  it('checkUrl method test ', async () => {
    const url1 = checkUrl('p2p://localhost/')
    expect(url1).toBe('p2p://localhost/')
    const url2 = checkUrl('p2p://localhost/b?a=1&b=2')
    expect(url2).toBe('p2p://localhost/b?a=1&b=2')
    const url3 = checkUrl('/a/b', 'localhost', 80)
    expect(url3).toBe('p2p://localhost:80/a/b')
    const url4 = checkUrl('/a/b?a=1&b=2', 'localhost', 80)
    expect(url4).toBe('p2p://localhost:80/a/b?a=1&b=2')
    const url5 = checkUrl('/a/b/?a=1&b=2', 'localhost', 80)
    expect(url5).toBe('p2p://localhost:80/a/b/?a=1&b=2')
    try {
      checkUrl({ host: 'localhost', port: 80 })
    } catch (err) {
      expect(err.message).toBe('Must specify a non-empty string, but instead got: ' + util.inspect({ host: 'localhost', port: 80 }, { depth: null }))
    }
    try {
      checkUrl('a/b?a=1&b=2')
    } catch (err) {
      expect(err.message).toBe('Must specify protocol to p2p:// or start with /, but instead got: ' + 'a/b?a=1&b=2')
    }
    try {
      checkUrl('/localhost:8080/b?a=1&b=2')
    } catch (err) {
      expect(err.message).toBe('Must specify protocol to p2p:// or start with /, but instead got: ' + 'a/b?a=1&b=2')
    }
    try {
      checkUrl('http://localhost:8080/b?a=1&b=2')
    } catch (err) {
      expect(err.message).toBe('Must specify protocol to p2p:// or start with /, but instead got: ' + 'http://localhost:8080/b?a=1&b=2')
    }
    try {
      checkUrl('https://localhost:8080/b?a=1&b=2')
    } catch (err) {
      expect(err.message).toBe('Must specify protocol to p2p:// or start with /, but instead got: ' + 'https://localhost:8080/b?a=1&b=2')
    }
  })

  it('parseUrl method test ', async () => {
    const result = parseUrl('p2p://localhost:8080/b?a=1&b=2')
    expect(result.protocol).toBe('p2p:')
    expect(result.host).toBe('localhost:8080')
    expect(result.port).toBe('8080')
    expect(result.hostname).toBe('localhost')
    expect(result.pathname).toBe('/b')
    expect(result.params.get('a')).toBe('1')
    expect(result.params.get('b')).toBe('2')
  })

  it('js type test ', async () => {
    expect(typeof undefined === 'undefined').toBe(true)
    expect(typeof 0 === 'number').toBe(true)
    expect(typeof 10000 === 'number').toBe(true)
    expect(typeof false === 'boolean').toBe(true)
    expect(typeof true === 'boolean').toBe(true)
    expect(typeof '' === 'string').toBe(true)

    expect(typeof (() => {}) === 'function').toBe(true)
    expect(typeof null === 'object').toBe(true)
    expect(typeof {} === 'object').toBe(true)
    expect(typeof [] === 'object').toBe(true)
    expect(typeof Buffer.from('') === 'object').toBe(true)
    expect(typeof (new (class {})()) === 'object').toBe(true)
    expect(typeof (new Map()) === 'object').toBe(true)
    expect(typeof (new Set()) === 'object').toBe(true)

    expect(undefined == 0).toBe(false)
    expect(0 == null).toBe(false)
    expect(0 == false).toBe(true)
    expect(0 == '').toBe(true)
    expect(0 == '0').toBe(true)
    expect(1 == true).toBe(true)
    expect(1 == '1').toBe(true)
    expect(1000 == '1000').toBe(true)
    expect(1000 == true).toBe(false)
    expect(!1000 == false).toBe(true)
    expect(undefined == false).toBe(false)
    expect(false == 0).toBe(true)
    expect(false == '').toBe(true)
    expect(false == null).toBe(false)
    expect(true == 1).toBe(true)
    expect(true == 10).toBe(false)
    expect(true == 'a').toBe(false)
    expect((() => {}) == true).toBe(false)
    expect({} == true).toBe(false)
    expect(undefined == '').toBe(false)
    expect('' == 0).toBe(true)
    expect('' == false).toBe(true)
    expect('' == null).toBe(false)
    expect('a' == true).toBe(false)
    expect('false' == false).toBe(false)
    expect('true' == true).toBe(false)
    expect(undefined == null).toBe(true)
    expect({} == true).toBe(false)

    expect(undefined === 0).toBe(false)
    expect(0 === null).toBe(false)
    expect(0 === false).toBe(false)
    expect(0 === '').toBe(false)
    expect(1 === true).toBe(false)
    expect(1 === '1').toBe(false)
    expect(undefined === false).toBe(false)
    expect(false === null).toBe(false)
    expect(false === 0).toBe(false)
    expect(false === '').toBe(false)
    expect(undefined === '').toBe(false)
    expect('' === null).toBe(false)
    expect('' === 0).toBe(false)
    expect('' === false).toBe(false)

    expect({} === {}).toBe(false)
    expect(undefined === null).toBe(false)

    expect(isNaN(0) === 'number').toBe(false)
    expect(isNaN('0')).toBe(false)
    expect(isNaN('1000')).toBe(false)

    expect(Array.isArray([])).toBe(true)
    expect(Buffer.isBuffer(Buffer.from(''))).toBe(true)
  })

  it('isBinary method test', async () => {
    const arr = new Uint8Array([1, 2, 3, 4, 5])
    const arr1 = new Int8Array([1, 2, 3, 4, 5])
    const buf = Buffer.from('hello')
    expect(typeof arr).toBe('object')
    expect(arr instanceof Array).toBe(false)
    expect(arr instanceof Buffer).toBe(false)
    expect(arr instanceof Uint8Array).toBe(true)
    expect(arr1 instanceof Array).toBe(false)
    expect(arr1 instanceof Buffer).toBe(false)
    expect(arr1 instanceof Int8Array).toBe(true)
    expect(Array.isArray(arr)).toBe(false)
    expect(Buffer.isBuffer(arr)).toBe(false)
    expect(Array.isArray(buf)).toBe(false)
    expect(isBinary(888)).toBe(false)
    expect(isBinary(2.5)).toBe(false)
    expect(isBinary({ a: 1 })).toBe(false)
    expect(isBinary(() => {})).toBe(false)
    expect(isBinary(new Map())).toBe(false)
    expect(isBinary(new Set())).toBe(false)
    expect(isBinary(new class {}())).toBe(false)
    expect(isBinary('')).toBe(false)
    expect(isBinary('')).toBe(false)
    expect(isBinary('""')).toBe(false)
    expect(isBinary("''")).toBe(false)
    expect(isBinary('')).toBe(false)
    expect(isBinary('""')).toBe(false)
    expect(isBinary('\'\'')).toBe(false)
    expect(isBinary('hello')).toBe(false)
    expect(isBinary([{ a: 1 }])).toBe(false)
    expect(isBinary([[1, 2], [3, 4]])).toBe(false)
    expect(isBinary(0)).toBe(false)
    expect(isBinary(false)).toBe(false)
    expect(isBinary(null)).toBe(false)
    expect(isBinary(undefined)).toBe(false)
    expect(isBinary('')).toBe(false)
    expect(isBinary(arr)).toBe(true)
    expect(isBinary(arr1)).toBe(true)
    expect(Buffer.isBuffer(buf)).toBe(true)
    expect(isBinary(buf)).toBe(true)
  })

  it('isText method test', async () => {
    const arr = new Uint8Array([1, 2, 3, 4, 5])
    const arr1 = new Int8Array([1, 2, 3, 4, 5])
    const buf = Buffer.from('hello')
    expect(isText(888)).toBe(false)
    expect(isText(2.5)).toBe(false)
    expect(isText({ a: 1 })).toBe(false)
    expect(isText(() => {})).toBe(false)
    expect(isText(new Map())).toBe(false)
    expect(isText(new Set())).toBe(false)
    expect(isText(new class {}())).toBe(false)
    expect(isText(arr)).toBe(false)
    expect(isText(arr1)).toBe(false)
    expect(isText(buf)).toBe(false)
    expect(isText([{ a: 1 }])).toBe(false)
    expect(isText([[1, 2], [3, 4]])).toBe(false)
    expect(isText(0)).toBe(false)
    expect(isText(false)).toBe(false)
    expect(isText(undefined)).toBe(false)
    expect(isText(null)).toBe(false)
    expect('' === '').toBe(true)
    expect(`${''}` === '').toBe(true)
    expect(`${''}` === '').toBe(true)
    expect(`${''}` === '').toBe(true)
    expect(isText('')).toBe(true)
    expect(isText('')).toBe(true)
    expect(isText('\'\'')).toBe(true)
    expect(isText('""')).toBe(true)
    expect(isText(`${''}`)).toBe(true)
    expect(isText(`${''}`)).toBe(true)
    expect(isText('hello')).toBe(true)
  })
})
